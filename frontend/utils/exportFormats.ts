
import { Metadata } from '../types';

/**
 * Pobiera Blob dla pliku tekstowego
 */
const createBlob = (content: string, type: string = 'text/csv;charset=utf-8;') => {
    return new Blob([content], { type });
};

/**
 * Format DistroKid (Symulacja formatu bulk upload)
 */
export const generateDistroKidCsv = (metadata: Metadata): Blob => {
    const headers = ['Title', 'Artist', 'Album', 'Year', 'Genre', 'ISRC', 'Explicit', 'Preview Start'];
    const row = [
        metadata.title || '',
        metadata.artist || '',
        metadata.album || metadata.title || '',
        metadata.year || new Date().getFullYear().toString(),
        metadata.mainGenre || 'Pop',
        metadata.isrc || '',
        metadata.explicitContent === 'Explicit' ? 'Y' : 'N',
        '0:00' // Default
    ];
    
    // CSV escaping
    const escape = (t: string) => `"${String(t).replace(/"/g, '""')}"`;
    const csvContent = headers.join(',') + '\n' + row.map(escape).join(',');
    
    return createBlob(csvContent);
};

/**
 * Format Tunecore (Symulacja)
 */
export const generateTunecoreCsv = (metadata: Metadata): Blob => {
    const headers = ['Song Title', 'Main Artist', 'Album Title', 'Release Year', 'Primary Genre', 'Secondary Genre', 'ISRC', 'Composer', 'Language'];
    const row = [
        metadata.title || '',
        metadata.artist || '',
        metadata.album || '',
        metadata.year || '',
        metadata.mainGenre || '',
        metadata.additionalGenres?.[0] || '',
        metadata.isrc || '',
        metadata.composer || '',
        metadata.language || 'English'
    ];
    
    const escape = (t: string) => `"${String(t).replace(/"/g, '""')}"`;
    const csvContent = headers.join(',') + '\n' + row.map(escape).join(',');
    
    return createBlob(csvContent);
};

/**
 * Format Internet Archive (CSV Metadata)
 * Standard dla Community Audio: https://archive.org/help/upload-csv.php
 */
export const generateInternetArchiveCsv = (metadata: Metadata): Blob => {
    const headers = ['title', 'creator', 'album', 'date', 'subject', 'description', 'licenseurl', 'mediatype'];
    const row = [
        metadata.title || '',
        metadata.artist || '',
        metadata.album || '',
        metadata.year || '',
        [metadata.mainGenre, ...(metadata.keywords || [])].join(';'), // Subject = Tags
        metadata.trackDescription || '',
        'http://creativecommons.org/licenses/by-nc-nd/4.0/', // Default safe license suggestion
        'audio'
    ];
    
    const escape = (t: string) => `"${String(t).replace(/"/g, '""')}"`;
    const csvContent = headers.join(',') + '\n' + row.map(escape).join(',');
    
    return createBlob(csvContent);
};

/**
 * Generuje link do formularza MusicBrainz z wypeÅ‚nionymi polami (Pre-fill URL)
 */
export const getMusicBrainzSubmissionUrl = (metadata: Metadata): string => {
    const baseUrl = 'https://musicbrainz.org/release/add';
    const params = new URLSearchParams();
    
    if (metadata.title) params.append('name', metadata.title);
    if (metadata.artist) params.append('artist_credit.names.0.artist.name', metadata.artist);
    if (metadata.year) params.append('events.0.date.year', metadata.year);
    if (metadata.publisher) params.append('labels.0.name', metadata.publisher);
    if (metadata.catalogNumber) params.append('labels.0.catalog_number', metadata.catalogNumber);
    if (metadata.isrc) params.append('mediums.0.track.0.isrc', metadata.isrc);
    if (metadata.language) params.append('language', 'eng'); // Defaulting to eng mapping, logic can be expanded
    
    // Annotation / Description
    if (metadata.trackDescription) {
        params.append('annotation', `Metadata generated by Music Metadata Engine.\n\nDescription: ${metadata.trackDescription}`);
    }

    return `${baseUrl}?${params.toString()}`;
};

/**
 * Generuje sformatowany tekst gotowy do wklejenia w formularzu Discogs "Add Release"
 */
export const generateDiscogsSubmissionText = (metadata: Metadata): string => {
    return `
Title: ${metadata.title}
Artist: ${metadata.artist}
Label: ${metadata.publisher || 'Self-Released'}
Catalog#: ${metadata.catalogNumber || 'N/A'}
Format: Digital, File
Country: Worldwide
Released: ${metadata.year}
Genre: ${metadata.mainGenre}
Style: ${metadata.additionalGenres?.join(', ')}

Credits:
Composed By: ${metadata.composer || '-'}
Lyrics By: ${metadata.lyricist || '-'}

Notes:
${metadata.trackDescription || 'Produced and released independently.'}
ISRC: ${metadata.isrc || '-'}
BPM: ${metadata.bpm || '-'}
    `.trim();
};

/**
 * Generuje tekst sformatowany pod Genius.com
 */
export const generateGeniusSubmissionText = (metadata: Metadata): string => {
    return `
Primary Info:
Title: ${metadata.title}
Artist: ${metadata.artist}
Released: ${metadata.year}
Producer: ${metadata.composer || metadata.artist}

Tags:
${metadata.mainGenre}, ${metadata.additionalGenres?.join(', ')}

Description:
${metadata.trackDescription}
    `.trim();
};

/**
 * Generuje tekst zgÅ‚oszenia dla WhoSampled
 */
export const generateWhoSampledText = (metadata: Metadata): string => {
    return `
Submission Type: Original / Remix / Cover (Please Select)

Track Details:
Artist: ${metadata.artist}
Track Name: ${metadata.title}
Album: ${metadata.album || 'Single'}
Year: ${metadata.year}
Label: ${metadata.publisher || 'Self-Released'}

Links:
[Paste Spotify/YouTube link here]

Contains sample of:
[Artist - Track Name]
(Sample appears at 0:00)
    `.trim();
};

/**
 * Generuje opis wideo dla YouTube / SoundCloud (SEO Optimized)
 */
export const generateYouTubeDescription = (metadata: Metadata): string => {
    const tags = [
        metadata.mainGenre, 
        ...(metadata.additionalGenres || []), 
        ...(metadata.keywords || []),
        metadata.artist
    ].filter(Boolean).map(t => `#${t?.replace(/\s+/g, '')}`).join(' ');

    return `
ðŸŽµ **${metadata.title}** - ${metadata.artist}
Stream/Download: [Insert Smart Link]

ðŸ“ **Track Info:**
Album: ${metadata.album || 'Single'}
Year: ${metadata.year}
Genre: ${metadata.mainGenre}
Label: ${metadata.publisher || 'Independent'}

ðŸŽ¹ **Credits:**
Composition: ${metadata.composer || '-'}
Lyrics: ${metadata.lyricist || '-'}
ISRC: ${metadata.isrc || '-'}

ðŸ“œ **About:**
${metadata.trackDescription || ''}

---
${tags} #NewMusic #MusicDiscovery
    `.trim();
};

/**
 * Generuje gotowy kod QuickStatements dla Wikidanych (Advanced)
 * lub sformatowany tekst dla ludzkiego edytora.
 */
export const generateWikidataText = (metadata: Metadata): string => {
    return `
=== Wikidata Item Suggestion ===
Label (en): ${metadata.title}
Description (en): Song by ${metadata.artist}, released in ${metadata.year}
Alias: ${metadata.title} (${metadata.artist} song)

STATEMENTS:
instance of (P31): song (Q7366)
performer (P175): ${metadata.artist} (Search and link item ID)
publication date (P577): ${metadata.year}
genre (P136): ${metadata.mainGenre}
ISRC (P950): ${metadata.isrc || 'N/A'}
duration (P2047): ${metadata.duration} seconds
    `.trim();
};

/**
 * Generuje kod JSON-LD (Schema.org) dla SEO.
 * UÅ¼ytkownik moÅ¼e wkleiÄ‡ to na swojÄ… stronÄ™ internetowÄ… w sekcji <head>.
 */
export const generateJsonLd = (metadata: Metadata): string => {
    const schema = {
        "@context": "https://schema.org",
        "@type": "MusicRecording",
        "name": metadata.title,
        "byArtist": {
            "@type": "MusicGroup",
            "name": metadata.artist
        },
        "inAlbum": {
            "@type": "MusicAlbum",
            "name": metadata.album || metadata.title
        },
        "duration": `PT${Math.floor((metadata.duration || 0) / 60)}M${(metadata.duration || 0) % 60}S`,
        "isrcCode": metadata.isrc,
        "datePublished": metadata.year,
        "genre": metadata.mainGenre,
        "description": metadata.trackDescription
    };
    return `<script type="application/ld+json">\n${JSON.stringify(schema, null, 2)}\n</script>`;
};

/**
 * Generuje prosty plik XML w stylu DDEX (Electronic Release Notification)
 * Jest to uproszczona wersja do celÃ³w archiwizacyjnych/pokazowych.
 */
export const generateDDEXXml = (metadata: Metadata, fileName: string): Blob => {
    const xml = `<?xml version="1.0" encoding="UTF-8"?>
<ern:NewReleaseMessage xmlns:ern="http://ddex.net/xml/ern/411" ReleaseProfileVersionId="CommonReleaseTypes/14/AudioAlbumMusicOnly">
    <MessageHeader>
        <MessageThreadId>${crypto.randomUUID()}</MessageThreadId>
        <MessageSender>MusicMetadataEngine</MessageSender>
        <SentOn>${new Date().toISOString()}</SentOn>
    </MessageHeader>
    <ResourceList>
        <SoundRecording>
            <ResourceReference>${fileName}</ResourceReference>
            <ReferenceTitle>
                <TitleText>${metadata.title}</TitleText>
            </ReferenceTitle>
            <Duration>${metadata.duration}</Duration>
            <DetailsByTerritory>
                <DisplayArtist>
                    <PartyName>
                        <FullName>${metadata.artist}</FullName>
                    </PartyName>
                </DisplayArtist>
                <Genre>
                    <GenreText>${metadata.mainGenre}</GenreText>
                </Genre>
                <ParentalWarningType>${metadata.explicitContent === 'Explicit' ? 'Explicit' : 'NotExplicit'}</ParentalWarningType>
            </DetailsByTerritory>
        </SoundRecording>
    </ResourceList>
    <ReleaseList>
        <Release>
            <ReleaseId>
                <ICPN>${metadata.catalogNumber || 'N/A'}</ICPN>
            </ReleaseId>
            <ReferenceTitle>
                <TitleText>${metadata.album || metadata.title}</TitleText>
            </ReferenceTitle>
            <ReleaseLabelReference>${metadata.publisher || 'Independent'}</ReleaseLabelReference>
            <PLine>
                <Year>${metadata.year}</Year>
                <PLineText>${metadata.copyright}</PLineText>
            </PLine>
        </Release>
    </ReleaseList>
</ern:NewReleaseMessage>`;

    return createBlob(xml, 'application/xml');
};
